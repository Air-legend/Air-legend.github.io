[ { "title": "局域网远程连接jupyter notebook lab", "url": "/posts/jupter_lab_remote/", "categories": "tools", "tags": "jupyter notebook", "date": "2023-01-30 12:10:00 +0800", "snippet": "安装1. 安装 conda/miniconda并进行初始化2. 安装 jupyterlab&gt; conda install -c conda-forge jupyterlab配置1. 创建 config 文档&gt; jupyter notebook --generate-config ## 2. 设置登录密码&gt; jupyter notebook password ## 3. 配置config文件一般保存在 ~/.jupyter/jupyter_notebook_config.py&gt; c.NotebookApp.notebook_dir = '/home/digisky/notebooks' &gt; c.NotebookApp.ip='*' # 允许所有ip访问 &gt; c.NotebookApp.open_browser = False # 不打开浏览器 &gt; c.NotebookApp.port =8872 #指定端口，不要用默认8888端口！公网上不用默认端口是好文明 &gt; c.NotebookApp.allow_remote_access = True #允许远程机器访问3. 加入想要使用的conda环境&gt; python -m ipykernel install --user --name xx --display-name \"显示的名字\"添加过后可通过 jupyter kernelspec list 查看4. 如果显示加载conda环境错误，修改conda kernel的路径文件一般保存在 ~/.local/share/jupyter/kernels将其中的 **kernel.json** 文件中的解释器路径修改为 /home/digisky/miniconda3/envs/xx/bin/python 路径启动&gt; jupyter lab -p 8872新增 debug 功能 依赖 sudo apt install nodejs sudo apt install npm 前端 jupyter labextension install @jupyterlab/debugger 后端 conda install xeus-python -c conda-forge " }, { "title": "Multi Game Decision Transformers", "url": "/posts/MGDT/", "categories": "Deep Learning, RL", "tags": "DeepMind, Machine Learning", "date": "2022-08-10 15:50:00 +0800", "snippet": "简介研究人员提出了一种Multi-Game Decision Transformer通用结构，能够有效的执行多种任务和快速的学习决策新任务。模型利用基于 transformer 的模型在 offline 情况下训练出在46个 atari 游戏中接近人类玩家水平的智能体。同时，该模型在视觉和语言任务中的某些方面，包括模型尺寸对表现的影响（文章使用 power-law 来说明）和通过 fine-tuning 在新任务上的快速适应能力上有着类似的趋势。老样子，经过各种实验比对，证实该模型拥有最棒的表现和扩展性。强化学习序列模型文章将离线强化学习过程看作是一个序列模型问题，以历史token $x_{&lt;i}$ 作为条件来建模 $x_i$ 的概率分布 $P_\\theta(x_i|x_{&lt;i})$, 其中序列使用了以下定义形式:\\[x = &lt;...,o_1^t, ..., o_M^t, \\hat{R}^t, a^t, r^t, ...&gt;\\]其中 $t$ 是当前时间步，$M$ 表示将每个 obs 图像观测切分的数量， $\\hat{R}^t$表示 $t$ 时刻的累积回报。整个编码结构如上图所示。文章使用标准交叉熵损失 cross-entropy loss来预测回报，动作以及奖励的离散化 token 训练模型。Tokenization回报 $\\hat{R}^t$，动作$a^t$，以及奖励$r^t$均被离散 token 化: 动作在环境考虑中默认为离散化的 奖励转换为三元标量{-1, 0, +1}中 累积回报均匀的进行离散化 切割后的 obs petch 和可训练的位置编码（position encoding）被映射到线性编码空间，编码成为模型对应输入的token。Train文章提到模型的训练是通过一个现有的 Atari trajectories 离线数据集来进行训练的，该数据集包括一个DQN模型训练中采集到的所有行动轨迹（包含学习初期的）。研究人员从中选择了46个DQN表现明显高于随机策略的游戏数据，其中41个游戏用于训练，另外5个游戏用于验证该方法的泛化性，包括: Alien (Maze based) MsPacman (Maze based) Pong (ball tracking) SpaceInvaders (shoot vertically) StarGunner (shoot horizontally) 训练中的图像数据被切分为6x6个patch，每一个patch为14x14像素，用于训练的41种游戏数据总计 41 亿个step， 1600亿条token。训练用的数据集包含了DQN所有的行为，文章说没有对其进行任何特殊过滤手段，原因主要有两点：1. 次优行为会产生更多的数据多样性可以帮助模型学习环境表达和糟糕行为导致的严重后果。2.很难从大量数据中给予明确的判定该数据是否是高质量数据。因此，从所有行为中训练模型，而在推理中生成专家行为。Expert Action Inference由于用于训练的数据不全是专家经验，因此很难通过模仿学习直接产生专家行为。文章提出在推理时使用一个分类器$P(expert^t|…)$ 在t时刻做出动作前来判断该动作是否是专家级别，根据贝叶斯规则，t时刻该专家级别行为的回报分布可以表示为:\\[P(R^t | expert^t, ...) \\propto P_\\theta(R^t|...)P(expert^t|R^t,...)\\]作者提出定义一个与回报成比例的逆温度参数 $\\kappa$ :\\[P(expert^t|R^t, ...) \\equiv exp(\\kappa R^t)\\]按照这种思路我们可以构建出一个简单的自回归过程：首先我们根据对数概率\\[\\log{P_\\theta(R^t|expert^t,...)} \\rightarrow \\log{P_\\theta(R^t|...)} + \\kappa R^t\\] 采样出一个合理的回报$R^t$，然后根据 $ P_\\theta(a^t R^t,…) $ 采样出动作，其中绿色框框$P_\\theta(R …)$和黄色框框$P_\\theta(a R,…)$是序列模型学习得到的分布输出。 总结总的来说文章是一个将transformer结构使用在RL中的不错案例，不仅证明强化学习也能够将模型进一步加深，同时还证实了RL的多任务同模型的可行性。transformer在CV和NLP已经有不错的表现，期待继续在RL中深入，取得更好成就。" }, { "title": "Transformer学习", "url": "/posts/transformer/", "categories": "Deep Learning", "tags": "Machine Learning", "date": "2022-08-10 10:42:00 +0800", "snippet": "bilibili 视频学习链接编码器位置编码： $PE_(pos,2i) = sin(pos/10000^{2i/d_{model}}) $$PE_(pos,2i+1) = cos(pos/10000^{2i/d_{model}})$借助正余弦公式: $ sin(\\alpha+\\beta) = sin\\alpha cos\\beta + cos\\alpha sin\\beta $$ cos(\\alpha+\\beta) = cos\\alpha cos\\beta - sin\\alpha sin\\beta $$\\rightarrow$ $ PE(pos+k,2i) = PE(pos,2i)PE(k,2i+1) + PE(pos, 2i+1) *PE(k,2i) $ $ PE(pos+k, 2i+1) = PE(pos,2i+1)PE(k,2i+1) - PE(pos,2i)*PE(k,2i)$可以看出， 对于 pos+k 的位置向量某一位 2i 或者 2i+1 而言。可以表示为，pos 位置与 k 位置的位置向量的 2i 与 2i+1 维的线性组合，这样的组合意味着位置向量中蕴涵了相对位置信息。ps: 但是这种相对位置信息会在注意力机制那里消失。最后：embedding + pose_embedding 作为编码器的输入注意力机制 公式：$ Attention(Q,K,V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})V $" }, { "title": "一切的开始", "url": "/posts/%E4%B8%80%E5%88%87%E7%9A%84%E5%BC%80%E5%A7%8B/", "categories": "Blogging", "tags": "个人记录", "date": "2022-07-26 10:50:00 +0800", "snippet": "今天开始搭建属于自己的 github page 博客。" }, { "title": "协程 & asyncio & 异步编程", "url": "/posts/python%E5%A4%9A%E8%BF%9B%E7%A8%8B/", "categories": "Technology, python", "tags": "async-tec", "date": "2021-07-02 11:56:00 +0800", "snippet": "1.协程​\t协程（Coroutine）不是计算机提供，程序员人为创造。​\t通过一个线程实现代码块相互切换执行。实现方法：1. greenlet，早期模块 \t2. yield关键字 \t3. asyncio装饰器（py3.4⬆️） \t4. async，await关键字（py3.5⬆️）【推荐】1.1 greenlet实现协程pip install greenletfrom greenlet import greenletdef func1(): print(1) gr2.switch() print(2) gr2.switch()def func2(): print(3) gr1.switch() print(4)gr1 = greenlet(func1)gr2 = greenlet(func2)gr1.switch()# 输出 &gt; 1 3 2 41.2 yield关键字def func1(): yield 1 yield from func2() yield 2def func2(): yield 3 yield 4f1 = func1()for item in f1: print(item)1.3 asynciopython3.4及之后的版本。import asyncio@asyncio.coroutinedef func1(): print(1) yield from asyncio.sleep(2) \t# 遇到IO耗时操作（阻塞），自动切换到tasks中的其他任务 print(2)@asyncio.coroutinedef func2(): print(3) yield from asyncio.sleep(2) \t# 遇到IO耗时操作（阻塞），自动切换到tasks中的其他任务 print(4)tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))遇到 IO 阻塞自动切换1.4 async &amp; await 关键字python3.5 及之后的版本。import asyncioasync def func1(): print(1) await asyncio.sleep(2) \t# 遇到IO耗时操作（阻塞），自动切换到tasks中的其他任务 print(2)async def func2(): print(3) await asyncio.sleep(2) \t# 遇到IO耗时操作（阻塞），自动切换到tasks中的其他任务 print(4)tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))2.协程的意义​\t在一个线程中如果遇到了 IO 等待时间，线程不会等待，利用空闲时间去干点其他事。​\t案例： 下载三张图片 普通方式（同步） \"\"\" pip install requests\"\"\" import requests def download_image(url): \tprint('开始下载。') \tresponse = requests.get(url) \tprint('下载完成') \tfile_name = url.rsplit('_')[-1] \twith open(file_name, mode='wb') as file_object: \t\tfile_object.write(response.content) if __name__ == '__main__': \turl_list = ['1','2','3'] \tfor item in url_list: \t\tdownload_image(item) 协程方式（异步） \"\"\" 下载图片使用第三方模块 aiohttp\t\tpip install aiohttp \"\"\"import aiohttpimport asyncio async def fetch(session,url): print(\"发送请求： \", url) async with session.get(url, verify_ssl=False) as response: content = await response.content.read() file_name = url.rsplit('_')[-1]\t\twith open(file_name, mode='wb') as file_object:\t\t\tfile_object.write(response.content)async def main(): async with aiohttp.ClientSession() as session: url_list = ['1','2','3'] tasks = [asyncio.create_task(fetch(session, url)) for url in url_list] await asyncio.wait(task)if \"__name__\" ==__main__: asyncio.run(main()) 3.异步编程3.1 事件循环​\t理解为一个死循环，检测并执行某些代码。# 伪代码任务列表 = [任务1， 任务2， 。。。]while True:\t可执行列表，已完成列表 = 任务列表中检查所有的任务，将‘可执行’和‘已完成’的任务返回\tfor 就绪任务 in 可执行任务列表：\t\t\t执行已就绪任务\tfor 已完成任务 in 已完成任务列表：\t\t\t在任务列表中删除 已完成任务\tif 任务列表 中的任务都已王成：\t\t\tbreakimport asyncio # 生成或获取一个时间循环loop = asyncio.get_event_loop()# 将任务放到 “任务列表”loop.run_until_complete(任务)3.2 async 快速上手​\t协程函数：定义函数的时候 async def 函数名.​\t协程对象： 执行 协程函数() 得到的协程对象# 协程函数async def func(): pass# 协程对象result = func()注意： 执行协程函数创建协程对象，函数内部代码不会执行。如果想要执行内部代码，必须将协程对象交给时间循环来处理。async def func(): print('hello world!')result = func()# loop = asyncio.get_event_loop()# loop.run_until_complete(restlt)asyncio.run(result)\t# python3.7 以后将两行简化成为一行3.3 await​\tawait + 可等待的对象（协程对象， Future对象， Task对象 =&gt; 理解为 IO 等待）import asyncioasync def func(): print('hello world')\tresponse = await asyncio.sleep(2) print('end ', response)asyncio.run(func())import asyncioasync def others(ids=0): print('start:', ids) await asyncio.sleep(2) print('end:', ids) return '返回'async def func(): print('执行协程函数内部代码') # response1 = await others() # print('r1: ',response1) # response2 = await others() # print('r2: ',response2) tasks = [ others(1), others(2)] await asyncio.wait(tasks)asyncio.run(func())​\tawait 就是等待对象的值得到结果之后再继续向下执行。3.4 Task对象​\t在事件循环中添加多个任务。​\tTasks用于并发协程调度，通过asyncio.create_task(协程对象) 的方式创建Task对象，这样可以让协加入事件循环中等待被调度执行。除了使用 asyncio.create_task() 函数以外，还可以用低层级的 loop.create_task() 或 ensure_future() 函数。建议用asyncio.create_task()，不建议手动实力化 Task 对象。示例1:import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return '返回'async def main(): task1 = asyncio.create_task(func()) task2 = asyncio.create_task(func()) print('main end') ret1 = await task1 ret2 = await task2 print(ret1, ret2)asyncio.run(main())示例2:import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return '返回'async def main(): task_list = [ asyncio.create_task(func(),name='n1'), asyncio.create_task(func(),name='n2') ] print('main end') done, pending = await asyncio.wait(task_list, timeout=3) print(done)asyncio.run(main())示例3:import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return '返回'task_list = [ func(), func()]done, pending = asyncio.run( asyncio.wait(task_list) )3.5 asyncio.Future对象​\tTask继承Future， Task对象内部 await 结果的处理基于 Future 对象来的。​\t示例1：async def main(): \t# 获取当前事件循环 \tloop = asyncio.get_running_loop() # 创建一个任务（Future对象）， 这个任务什么都不干 fut = loop.create_future() # 等待任务最终结果（Future对象），没有结果则会一直等下去 await fut# 这里创建事件循环asyncio.run(main())示例2:import asyncioasync def set_after(fut): await asyncio.sleep(2) fut.set_result('666')async def main(): # 获取当前事件循环 loop = asyncio.get_running_loop() # 创建一个任务（Future对象）， 这个任务什么都不干 fut = loop.create_future() # 创建一个任务，绑定了set_after函数，函数会给fut赋值 await loop.create_task(set_after(fut)) # 等待任务最终结果（Future对象），没有结果则会一直等下去 data = await fut print(data)# 这里创建事件循环asyncio.run(main())3.6 concurrent.futures.Future对象​\t使用线程池或进程池异步操作时用到的对象。（线程池/进程池中的线程/进程可以使用协同函数）import timefrom concurrent.futures import Futurefrom concurrent.futures.thread import ThreadPoolExecutorfrom concurrent.futures.process import ProcessPoolExecutordef func(value): time.sleep(1) print(value)\treturn 1\t# 返回给future对象# 创建线程池pool = ThreadPoolExecutor(max_workers=5)# 创建进程池pool = ProcessPoolExecutor(max_workers=5)for i in range(10): fut = pool.submit(func, i) print(fut)案例：asyncio + 不支持asyncio异步的模块3.7 异步迭代器异步迭代器\t实现了__aiter__()和__anext__()方法的对象。异步可叠戴对象\t可在async_for 语句中被使用的对象import asyncioclass Reader(): \"\"\" 定义异步迭代器（同时也是异步可迭代对象） \"\"\" def __init__(self): self.count = 0 async def readline(self): self.count += 1 if self.count == 100: return None \treturn self.count def __aiter__(self): return self async def __anext__(self): val = wait self.readline() if val == None: raise StopAsyncIteration return valasync def func(): obj = Reader() async for item in obs: \tprint(item)asyncio.run(func())3.8 异步上下文管理器import asyncioclass AsyncContextManager: def __init__(self): self.conn = conn" } ]
